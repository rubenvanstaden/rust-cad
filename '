use std::f32::consts::PI;

pub struct Point {
    pub x: f32,
    pub y: f32,
}

pub struct Edge {
    pub p1: Point,
    pub p2: Point,
}

pub struct Rectangle {
    pub origin: Point,
    pub width: f32,
    pub height: f32,
}

pub struct Circle {
    pub origin: Point,
    pub radius: f32,
}

fn deg2rad(angle: f32) -> f32 {
    angle * PI/180.0
}

impl Point {
    pub fn new(x: f32, y: f32) -> Point {
        Point { x, y }
    }

    pub fn rotate(&mut self, angle: f32) {
        let theta = deg2rad(angle);
        let (x, y) = (self.x, self.y);
        self.x = x*theta.cos() - y*theta.sin();
        self.y = y*theta.cos() + x*theta.sin();
    }

    pub fn translate(&mut self, x: f32, y: f32) {
        self.x += x;
        self.y += y;
    }
}

impl Rectangle {
    pub fn area(&self) -> f32 {
        self.width * self.height
    }

    pub fn translate(&mut self, x: f32, y: f32) {
        self.origin.x += x;
        self.origin.y += y;
    }
}

impl Circle {
    pub fn area(&self) -> f32 {
        PI * self.radius.powi(2)
    }

    pub fn translate(&mut self, x: f32, y: f32) {
        self.origin.x += x;
        self.origin.y += y;
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn points_translate() {
        let mut p1 = shape::Point::new(1.0, 0.0);
    }
}
